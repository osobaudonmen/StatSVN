# GitHub Actions Workflow: Build and Release JAR
# Triggered: On push to main branch
# Creates: Automated releases tagged as build-<run_id> with JAR+docs zip
# Retention: Keeps latest 5 releases (generations), deletes older ones
# Files: Generates statsvn_r<run_number>.zip containing JAR, README.md, LICENSE

name: Build and Release JAR

on:
  push:
    branches:
      - master

jobs:
  build-and-release:
    name: Build and attach JAR
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write

    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          distribution: temurin
          java-version: '21'

      - name: Ensure build script is executable
        run: chmod +x ./build.sh

      - name: Build project
        run: |
          ./build.sh

      - name: Verify built JAR exists
        run: |
          if [ ! -f build/dist/statsvn.jar ]; then
            echo "ERROR: build/dist/statsvn.jar not found";
            ls -la build || true;
            exit 1;
          fi

      - name: Prepare release artifacts (zip containing JAR, README.md, LICENSE)
        id: prepare
        run: |
          set -e
          mkdir -p dist/statsvn
          ZIP_NAME="statsvn_r${{ github.run_number }}.zip"
          # Copy jar and docs into organized subdirectory
          cp build/dist/statsvn.jar dist/statsvn/
          cp README.md dist/statsvn/README.md || echo "Warning: README.md not found"
          cp LICENSE dist/statsvn/LICENSE || echo "Warning: LICENSE not found"
          # Create zip with directory structure
          cd dist
          zip -r "$ZIP_NAME" statsvn/ || { echo "ERROR: Failed to create zip"; exit 1; }
          ls -lh "$ZIP_NAME"
          echo "zip_name=$ZIP_NAME" >> $GITHUB_OUTPUT

      - name: Generate release body
        id: release_body
        run: |
          set -euo pipefail
          # Collect variables (these are expanded by GitHub Actions before the runner executes)
          COMMIT=${{ github.sha }}
          BRANCH=${{ github.ref_name }}
          RUN_NUMBER=${{ github.run_number }}
          ZIP_NAME=${{ steps.prepare.outputs.zip_name }}
          BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          # Attempt to list files added in this push (fallback gracefully)
          added_files=$(git diff --name-only --diff-filter=A ${{ github.event.before }} ${{ github.sha }} 2>/dev/null || true)

          # Create a clean release body file (use unquoted HEREDOC so shell variables expand)
          cat > /tmp/release_body.txt <<EOF
                ## Build Information

                - **Commit**: \\`${COMMIT}\\`
                - **Branch**: \\`${BRANCH}\\`
                - **Build Date (UTC)**: ${BUILD_DATE}

                ## Artifacts

                - **ZIP**: \\`${ZIP_NAME}\\`
                - Contains: \\`statsvn.jar\\`, \\`README.md\\`, \\`LICENSE\\`

                EOF

          echo "/tmp/release_body.txt created"

      - name: Create and push tag
        id: create_tag
        run: |
          TAG="build-${{ github.run_id }}"
          echo "Creating tag: $TAG"
          git config user.email "actions@github.com"
          git config user.name "github-actions[bot]"
          # Check if tag already exists
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "WARNING: Tag $TAG already exists, skipping tag creation"
          else
            git tag -a "$TAG" -m "Automated build $TAG - ${{ github.sha }}"
            git push origin "$TAG" || { echo "ERROR: Failed to push tag"; exit 1; }
            echo "Tag created and pushed: $TAG"
          fi
          echo "tag_name=$TAG" >> $GITHUB_OUTPUT



      - name: Create release and upload ZIP (using gh CLI)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e
          TAG=${{ steps.create_tag.outputs.tag_name }}
          ZIP=dist/${{ steps.prepare.outputs.zip_name }}
          echo "Creating or updating release for tag: $TAG"
          # If release exists, update notes and upload asset; otherwise create it
          if gh release view "$TAG" >/dev/null 2>&1; then
            echo "Release exists; updating notes and uploading asset"
            gh release edit "$TAG" --title "Release #${{ github.run_number }}" --notes-file /tmp/release_body.txt || true
            gh release upload "$TAG" "$ZIP" --clobber || true
          else
            gh release create "$TAG" "$ZIP" --title "Release #${{ github.run_number }}" --notes-file /tmp/release_body.txt
          fi

      - name: Cleanup old releases (keep latest 5)
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Cleaning up old releases (keeping latest 5)..."
          # gh CLI is pre-installed on Ubuntu runners
          # List releases that start with 'build-', sorted by createdAt descending, skip first 5
          releases=$(gh release list --limit 100 --json tagName,createdAt --jq 'map(select(.tagName | startswith("build-"))) | sort_by(.createdAt) | reverse | .[5:] | map(.tagName) | .[]')

          deleted_count=0
          for tag in $releases; do
            if [ -n "$tag" ] && [ "$tag" != "${{ steps.create_tag.outputs.tag_name }}" ]; then
              echo "Deleting old release: $tag"
              if gh release delete "$tag" --yes --cleanup-tag; then
                ((deleted_count++))
              else
                echo "Warning: Failed to delete $tag (might not exist)"
              fi
            fi
          done
          echo "Deleted $deleted_count old release(s)"
